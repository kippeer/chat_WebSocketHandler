package com.exemplo.chat.service;

import com.exemplo.chat.dto.MessageDTO;
import com.exemplo.chat.model.Message;
import com.exemplo.chat.enums.MessageType;
import com.exemplo.chat.exception.WebSocketException;
import com.exemplo.chat.handler.ChatWebSocketHandler;
import com.exemplo.chat.repository.MessageRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import java.io.IOException;
import java.time.LocalDateTime;

@Service
public class ChatService {
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Autowired
    private ChatWebSocketHandler chatHandler;

    @Autowired
    private MessageRepository messageRepository;

    public void handleMessage(WebSocketSession session, TextMessage textMessage) {
        try {
            MessageDTO messageDTO = objectMapper.readValue(textMessage.getPayload(), MessageDTO.class);

            if (messageDTO.getSender() == null || messageDTO.getSender().trim().isEmpty()) {
                throw new WebSocketException("Sender cannot be empty");
            }
            if (messageDTO.getContent() == null || messageDTO.getContent().trim().isEmpty()) {
                throw new WebSocketException("Message content cannot be empty");
            }

            Message message = new Message(
                    null, // ID will be generated by the database
                    messageDTO.getSender(),
                    messageDTO.getContent(),
                    LocalDateTime.now(),
                    messageDTO.getType()
            );

            message = messageRepository.save(message);

            String messageJson = objectMapper.writeValueAsString(message);
            broadcastMessage(session, new TextMessage(messageJson));
        } catch (IOException e) {
            throw new WebSocketException("Error processing message", e);
        }
    }

    public void handleJoin(WebSocketSession session) {
        try {
            String sessionId = session.getId();
            Message joinMessage = new Message(
                    null, // ID will be generated by the database
                    "System",
                    "User " + sessionId + " joined the chat",
                    LocalDateTime.now(),
                    MessageType.JOIN
            );

            joinMessage = messageRepository.save(joinMessage);

            sendMessageHistory(session);

            String messageJson = objectMapper.writeValueAsString(joinMessage);
            broadcastMessage(session, new TextMessage(messageJson));
        } catch (Exception e) {
            throw new WebSocketException("Error handling join", e);
        }
    }

    public void handleLeave(WebSocketSession session) {
        try {
            String sessionId = session.getId();
            Message leaveMessage = new Message(
                    null, // ID will be generated by the database
                    "System",
                    "User " + sessionId + " left the chat",
                    LocalDateTime.now(),
                    MessageType.LEAVE
            );

            leaveMessage = messageRepository.save(leaveMessage);

            String messageJson = objectMapper.writeValueAsString(leaveMessage);
            broadcastMessage(session, new TextMessage(messageJson));
        } catch (Exception e) {
            throw new WebSocketException("Error handling leave", e);
        }
    }

    private void sendMessageHistory(WebSocketSession session) {
        try {
            messageRepository.findTop50ByOrderByTimestampDesc()
                    .forEach(message -> {
                        try {
                            String messageJson = objectMapper.writeValueAsString(message);
                            session.sendMessage(new TextMessage(messageJson));
                        } catch (IOException e) {
                            throw new WebSocketException("Error sending message history", e);
                        }
                    });
        } catch (Exception e) {
            throw new WebSocketException("Error retrieving message history", e);
        }
    }

    private void broadcastMessage(WebSocketSession sender, TextMessage message) {
        for (WebSocketSession session : chatHandler.getSessions()) {
            try {
                if (session.isOpen()) {
                    session.sendMessage(message);
                }
            } catch (IOException e) {
                throw new WebSocketException("Error sending message to session: " + session.getId(), e);
            }
        }
    }
}